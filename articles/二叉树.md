# 特点

- 每个节点的度最大为 2，也就是每个节点最多拥有 2 个子树
- 非空二叉树的第 i 层，最多有 $2^{i−1}$个节点（层数从 1 开始计算）
- 高度为 h 的二叉树最多有 $2^h -1$ 个节点
- 对于任何一颗非空二叉树，叶子节点个数为 n0，度为 2 的节点个数为 n2，则：n0 = n2 + 1
	- 假设度为 1 的节点个数为 n1，则二叉树节点总数为 n = n0 + n1 + n2
	- 二叉树的边数 T = n - 1 = n1 + n2 * 2 = n0 + n1 + n2 - 1
	- 则 n0 = n2 + 1

# 分类

- 真二叉树：只存在度为 0 或 2 的节点
- 完美二叉树 / 满二叉树：除了最后一层节点的度都为 0，其他节点的度都为 2
- 完全二叉树：：对节点从上至下、左右开始编号，其所有都能与相同高度的满二叉树中的标号对应

![](http://oss.xiefeng.tech/img/20210628213501.png)

# 遍历

对于二叉树比较重要的一个操作就是遍历，遍历一共有四种方式：前序、中序、后序、层序。前三种对应于深度优先，后一种则对应于广度优先。

## 深度优先

实现深度优先搜索最简单的方式就是递归，而所谓的前序、中序、后序的区别在于根节点的访问时机不同。

- 前序是先访问根节点再访问左子树、右子树
- 中序是先访问左子树，然后是根节点、右子树
- 后序则是先访问左子树、右子树，最后才是根节点

```typescript
function traversal<T>(root: TreeNode<T> | null): void {
    if (root) {
        // 前序 visit(root);
        traversal(root.left);
        // 中序 visit(root);
        tranersal(root.right);
        // 后序 visit(root);
    }
}
```

![DFS轨迹](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/20210201190534.svg)

虚线就是深度优先搜索时的路径，可以发现度为0节点会被访问一次，度为1的节点会被访问2次，度为2的节点会被访问3次。

前序、中序、后序遍历也可以指第几次到该节点的时候执行访问操作，当左右子树都存在时，前序就是第一次，中序就是第二次，后序就是第三次。

### 前序遍历

基本上所有的递归都可以改为迭代，递归的特点就是保留了以前的状态，改为迭代自然就需要一个栈来辅助保存以前访问过的节点。

迭代的一种实现思路：

1. `root` 入栈
2. 循环以下操作直到栈空：
	1. pop 出 `top` 然后访问
	2. `top.right` 入栈
	3. `top.left` 入栈

```typescript
function preorderTraversal<T>(root: TreeNode<T>): void {
    const stack: TreeNode<T>[] = [];
    stack.push(root);
    while (stack.length) {
        const node = stack.pop();
        // visit(node);
        node.right && stack.push(node.right);
        node.left && stack.push(node.left);
    }
}
```

### 中序遍历

中序遍历的实现还是比较容易的：

- 从根节点开始一直将左子节点入栈
- 弹出最左的叶子节点进行访问
- 查看是否存在右子树，存在则重复该操作
- 不存在则弹出父节点，重复操作

```typescript
function inorderTraversal<T>( root: TreeNode<T>): void {
    const stack: TreeNode<T>[] = [];
    let node: TreeNode<T> | null = root;
    while (node || stack.length) {
        while (node) {
            stack.push(node);
            node = node.left;
        }
        node = stack.pop();
        // visit(node);
        node = node.right;
    }
}
```

其实这个实现简单修改一下也可用于前序遍历：

```typescript
function preorderTraversal<T>( root: TreeNode<T>): void {
    const stack: TreeNode<T>[] = [];
    let node: TreeNode<T> | null = root;
    while (node || stack.length) {
        while (node) {
            // visit(node);
            stack.push(node);
            node = node.left;
        }
        node = stack.pop();
        node = node.right;
    }
}
```

### 后序遍历

后序遍历的非递归是比较难想的，这里提供一种思路：

![后序遍历](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/20210201193858.svg)

我们按照虚线的路线入栈，就是根节点先入栈，然后依次循环的分别让右子节点，左子节点入栈。

对于这样的二叉树最后的节点依次出栈就是后序遍历的顺序，但这是所有的右子树只有根节点的情况，所以再循环中需要判断一下是需要继续入栈还是出栈访问。

出栈访问的判断条件应该是：栈顶节点是叶子节点 / 上一次访问的节点是栈顶节点的子节点（图中节点 2 的情况，子节点都访问完了该轮到自己了）

整体步骤就是：

1. `root` 入栈
2. 循环以下操作直到栈空：
	- 如果栈顶节点是叶子节点 / 上一次访问的节点是栈顶节点的子节点：弹出栈顶节点并访问
	- 否则：将栈顶节点的 `right`、`left` 入栈

```typescript
function postorderTraversal<T>(root: TreeNode<T>): void {
    const stack: TreeNode<T>[] = [];
    stack.push(root);
    let prev: TreeNode<T> | null = null // 前一个弹出/访问的元素
    while (stack.length) {
        const top = stack[stack.length - 1]; // stack.peek()
        if (top.isLeave() || (top.left === prev || top.right === prev)) {
            // visit(top);
            prev = stack.pop()
        } else {
            top.right && stack.push(top.right);
            top.left && stack.push(top.left);
        }
    }
}
```

## 广度优先

所谓的 BFS 就是利用队列将同一层的节点保存起来然后访问，在访问的同时将下一层的节点也入队列。

```typescript
function levelOrderTraversal<T>(root: TreeNode<T>) {
    const queue: TreeNode<T> = [];
    queue.push(root); // enqueue
    while (queue.length) {
        const node = queue.shift(); // dequeue
        // visit(node);
        node.left && queue.push(node.left); // enqueue 
        node.right && queue.push(node.right); // enqueue
    }
}
```

# 前驱节点

所谓前驱节点就是一个节点在中序遍历时的前一个节点。

对于二叉搜索树来说很好找就是左子树的最大值，但是对于一般的二叉树就稍微麻烦点。

- 对于一个存在左子树的节点来说，中序遍历的前一个节点就是它左子树的最 `right` 的节点，例如：8、4、13 等节点
- 对于一个不存在左子树的节点来说
	- 如果有父节点的存在并且能一直向上找到向左的开叉，则就存在前驱节点，例如：3、7、9 等节点
	- 否则就没有前驱节点，例如：1

![](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/20210201202334.svg)

```typescript
function predecessor<T>(root: TreeNode<T>): TreeNode<T> | null {
    // 存在左子节点，找 root.left.right.right.……
    if (root.left) {
        let node = root.left;
        while (node.right) {
            node = node.right;
        }
        return node;
    }
    // 没有左子节点但是存在父节点的情况，找向左的分叉
    while (root.parent && root === root.parent.left) {
        root = root.parent;
    }
    return root.parent;
}
```

# 后继节点

后继节点类似于前驱节点，它是一个节点在中序遍历时的后一个节点，对于二叉搜索树就是右子树的最小值。

- 对于一个存在右子树的节点来说，中序遍历的前一个节点就是它右子树的最 `left` 的节点，例如：8、4、10 等节点
- 对于一个不存在右子树的节点来说
	- 如果有父节点的存在并且能一直向上找到向右的开叉，则就存在后继节点，例如：12、1、3 等节点
	- 否则就没有后继节点，例如：13

```typescript
function successor<T>(root: TreeNode<T>): TreeNode<T> | null {
    if (root.right) {
        let node = root.right;
        while (node.left) {
            node = node.left;
        }
        return node;
    }
    // 没有右子节点但是存在父节点的情况，找向右的分叉
    while (root.parent && root === root.parent.right) {
        root = root.parent;
    }
    return root.parent;
}
```

